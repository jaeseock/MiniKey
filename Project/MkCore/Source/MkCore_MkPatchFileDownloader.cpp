
#include <Windows.h>
#include "MkCore_MkDevPanel.h"
#include "MkCore_MkFileManager.h"
#include "MkCore_MkInterfaceForFileWriting.h"
#include "MkCore_MkInterfaceForFileReading.h"
#include "MkCore_MkZipCompressor.h"
#include "MkCore_MkFileDownloader.h"
#include "MkCore_MkPatchFileGenerator.h"
#include "MkCore_MkPatchFileDownloader.h"


const MkStr MkPatchFileDownloader::TemporaryRepositoryDirName(L"__TempRep\\");


//------------------------------------------------------------------------------------------------//

bool MkPatchFileDownloader::CheckAndDownloadPatchFile(const MkStr& url)
{
	bool ok = (m_MainState == eReady);
	if (ok)
	{
		m_RootURL = url;
		if ((!m_RootURL.Empty()) && (!m_RootURL.CheckPostfix(L"/")))
		{
			m_RootURL += L"/"; // ex> http://210.207.252.151/Test -> http://210.207.252.151/Test/
		}

		m_DataRootURL = m_RootURL + MkPatchFileGenerator::PatchDataDirName;
		m_DataRootURL.BackSpace(1);
		m_DataRootURL += L"/"; // ex> http://210.207.252.151/Test/data/

		m_ErrorMsg.Clear();
		m_MainState = eDownloadPatchInfoFile;
		m_MaxProgress = 0;
		m_CurrentProgress = 0;
	}
	return ok;
}

void MkPatchFileDownloader::Update(void)
{
	switch (m_MainState)
	{
	case eReady: break;

	case eDownloadPatchInfoFile:
		{
			MkStr infoFileName = MkPatchFileGenerator::DataType_PatchInfo + L"." + MkDataNode::DefaultFileExtension; // ex> PatchInfo.mmd
			MkPathName infoFileNameDown;
			MkPatchFileGenerator::ConvertFilePathToDownloadable(infoFileName, infoFileNameDown); // ex> PatchInfo.mmd.rp

			// local temp dir
			MkPathName localTempDir = MkPathName::GetRootDirectory() + TemporaryRepositoryDirName; // ex> D:\\Client\\__TempRep\\

			// down info file
			MkStr urlInfoFilePath = m_RootURL + infoFileNameDown; // ex> http://210.207.252.151/Test/PatchInfo.mmd.rp
			MkPathName localInfoFilePath = localTempDir + infoFileName; // D:\\Client\\__TempRep\\PatchInfo.mmd

			switch (MkFileDownloader::Start(urlInfoFilePath, localInfoFilePath))
			{
			case MkFileDownloader::eInvalidURL: m_ErrorMsg = urlInfoFilePath + L"\n경로에 파일이 존재하지 않습니다."; break;
			case MkFileDownloader::eNetworkError: m_ErrorMsg = urlInfoFilePath + L"\n네트워크 오류로 다운이 실패했습니다."; break;
			case MkFileDownloader::eOutOfMemory: m_ErrorMsg = urlInfoFilePath + L"\n메모리 부족으로 다운이 실패했습니다."; break;
			}

			if (m_ErrorMsg.Empty())
			{
				MK_DEV_PANEL.MsgToLog(L"> " + urlInfoFilePath);
				MK_DEV_PANEL.MsgToLog(L"  설정 파일 다운 성공.");
				MK_DEV_PANEL.InsertEmptyLine();

				// load info file
				m_PatchInfoNode.Clear();
				if (m_PatchInfoNode.Load(localInfoFilePath))
				{
					unsigned int lastWT = 0;
					if ((m_PatchInfoNode.GetDataTypeTag() == MkPatchFileGenerator::DataType_PatchInfo) &&
						m_PatchInfoNode.ChildExist(MkPatchFileGenerator::KEY_StructureNode) &&
						m_PatchInfoNode.GetData(MkPatchFileGenerator::KEY_CurrWT, lastWT, 0))
					{
						MK_DEV_PANEL.MsgToLog(L"> " + localInfoFilePath);
						MK_DEV_PANEL.MsgToLog(L"  설정 파일 로딩 성공 : " + MkPatchFileGenerator::ConvertWrittenTimeToStr(lastWT));
						MK_DEV_PANEL.InsertEmptyLine();

						MkStr rfp;
						if (m_PatchInfoNode.GetData(MkPatchFileGenerator::KEY_RunFilePath, rfp, 0))
						{
							m_RunFilePath.ConvertToRootBasisAbsolutePath(rfp);

							MK_DEV_PANEL.MsgToLog(L"> " + m_RunFilePath);
							MK_DEV_PANEL.MsgToLog(L"  실행 파일 경로 설정");
							MK_DEV_PANEL.InsertEmptyLine();
						}
					}
					else
						m_ErrorMsg = urlInfoFilePath + L"\n위치의 파일은 정상적인 설정 파일이 아닙니다.";
				}
				else
					m_ErrorMsg = urlInfoFilePath + L"\n위치의 설정 파일 읽기 실패.";
			}

			if (m_ErrorMsg.Empty())
			{
				m_TempDataPath = localTempDir + MkPatchFileGenerator::PatchDataDirName; // ex> D:\\Client\\__TempRep\\data\\

				m_MainState = ePurgeDeleteList;
			}
			else
			{
				MK_DEV_PANEL.MsgToLog(m_ErrorMsg);
				MK_DEV_PANEL.InsertEmptyLine();

				m_MainState = eShowResult;
			}
		}
		break;

	case ePurgeDeleteList:
		{
			MkDataNode* purgeNode = m_PatchInfoNode.GetChildNode(MkPatchFileGenerator::KEY_PurgeListNode);
			if (purgeNode != NULL)
			{
				MkArray<MkHashStr> keys;
				purgeNode->GetChildNodeList(keys);

				if (!keys.Empty())
				{
					MK_DEV_PANEL.MsgToLog(L"> 파일 삭제 최대 " + MkStr(keys.GetSize()) + L" 개 파일");

					MK_INDEXING_LOOP(keys, i)
					{
						MkPathName targetFilePath = keys[i].GetString();

						// 실제 파일 있으면 삭제
						MkPathName absoluteFilePath;
						absoluteFilePath.ConvertToRootBasisAbsolutePath(targetFilePath);
						absoluteFilePath.DeleteCurrentFile();

						// file system상에 있으면 삭제
						MkFileManager::Instance().GetFileSystem().RemoveFile(targetFilePath);
					}

					MK_DEV_PANEL.InsertEmptyLine();
				}

				// purge node는 더 이상 필요 없음
				purgeNode->DetachFromParentNode();
				delete purgeNode;
			}

			m_MainState = eFindDownloadTargets;
		}
		break;

	case eFindDownloadTargets:
		{
			// client root에 file system 설정이 존재한다면 반영
			MkDataNode* fsSettingNode = m_PatchInfoNode.GetChildNode(MkPatchFileGenerator::KEY_FileSystemNode);
			if (fsSettingNode != NULL)
			{
				MkFileManager::Instance().GetFileSystem().SetSystemSetting(*fsSettingNode);

				// 더 이상 필요 없음
				fsSettingNode->DetachFromParentNode();
				delete fsSettingNode;

				MK_DEV_PANEL.MsgToLog(L"> 파일 시스템 설정 적용");
				MK_DEV_PANEL.InsertEmptyLine();
			}

			// structure 기준으로 다운받을 파일 검색(structure node 존재여부는 위에서 검사)
			const MkDataNode& structureNode = *m_PatchInfoNode.GetChildNode(MkPatchFileGenerator::KEY_StructureNode);
			unsigned int totalFiles = _CountTotalFiles(structureNode);
			MK_DEV_PANEL.MsgToLog(L"> 누적 패치 파일 : " + MkStr(totalFiles) + L" 개");

			m_DownloadFileInfoList.Clear();
			m_DownloadFileInfoList.Reserve(totalFiles);

			// module file name
			wchar_t fullPath[MAX_PATH];
			::GetModuleFileName(NULL, fullPath, MAX_PATH);
			MkPathName tmpBuf = fullPath;
			MkPathName moduleFileName = tmpBuf.GetFileName();
			moduleFileName.ToLower();

			_FindFilesToDownload(structureNode, MkStr::EMPTY, moduleFileName); // 검색

			MK_DEV_PANEL.MsgToLog(L"> 다운 대상 파일 : " + MkStr(m_DownloadFileInfoList.GetSize()) + L" 개");
			MK_DEV_PANEL.InsertEmptyLine();
			MK_DEV_PANEL.MsgToLog(L"> 파일 다운을 시작합니다.");

			m_MainState = eDownloadTargetFiles;
			m_MaxProgress = m_DownloadFileInfoList.GetSize();
			m_CurrentProgress = 0;
		}
		break;

	case eDownloadTargetFiles:
		{
			if (m_CurrentProgress == m_MaxProgress)
			{
				MK_DEV_PANEL.MsgToLog(L"> 파일 다운이 완료되었습니다.");
				MK_DEV_PANEL.InsertEmptyLine();
				MK_DEV_PANEL.MsgToLog(L"> 패치 파일을 적용합니다.");

				m_CurrentProgress = 0;
				m_MainState = eUpdateFiles;
			}
			else
			{
				// 이미 다운받은 경우면 스킵
				const _DownloadFileInfo& fileInfo = m_DownloadFileInfoList[m_CurrentProgress];
				if (!fileInfo.alreadyDowned)
				{
					// url
					MkPathName relPathInServer, relPathInClient;
					MkPatchFileGenerator::ConvertFilePathToDownloadable(fileInfo.filePath, relPathInServer); // ex> AAA\\BBB\\abc.mmd -> AAA\\BBB\\abc.mmd.rp
					relPathInClient = relPathInServer;
					relPathInServer.ReplaceKeyword(L"\\", L"/"); // ex> AAA/BBB/abc.mmd.rp
					MkStr urlPath = m_DataRootURL + relPathInServer; // ex> http://210.207.252.151/Test/data/AAA/BBB/abc.mmd.rp

					// local. 압축 여부에 따라 그대로 다운, 혹은 다운 후 압축해제
					MkPathName localFilePathForComp = m_TempDataPath + relPathInClient; // 압축. ex> D:\\Client\\__TempRep\\data\\AAA\\BBB\\abc.mmd.rp
					MkPathName localFilePathForOrig = m_TempDataPath + fileInfo.filePath; // 비압축. ex> D:\\Client\\__TempRep\\data\\AAA\\BBB\\abc.mmd
					bool compressed = (fileInfo.compSize > 0);

					// down
					switch (MkFileDownloader::Start(urlPath, (compressed) ? localFilePathForComp : localFilePathForOrig))
					{
					case MkFileDownloader::eInvalidURL: m_ErrorMsg = urlPath + L"\n경로에 파일이 존재하지 않습니다."; break;
					case MkFileDownloader::eNetworkError: m_ErrorMsg = urlPath + L"\n네트워크 오류로 다운이 실패했습니다."; break;
					case MkFileDownloader::eOutOfMemory: m_ErrorMsg = urlPath + L"\n메모리 부족으로 다운이 실패했습니다."; break;
					}

					if (m_ErrorMsg.Empty())
					{
						do
						{
							// uncompress!!! -> WT 변경!!!!
							if (compressed)
							{
								// 압축 파일 읽어들여
								MkByteArray compData;
								MkInterfaceForFileReading frInterface;
								if (!frInterface.SetUp(localFilePathForComp))
								{
									m_ErrorMsg = localFilePathForComp + L"\n파일 열기 실패.";
									break;
								}
								if (frInterface.Read(compData, MkArraySection(0)) != fileInfo.compSize)
								{
									m_ErrorMsg = localFilePathForComp + L"\n읽기 오류거나 다운된 압축 파일 크기가 다릅니다.";
									break;
								}
								frInterface.Clear();

								// 압축 해제
								MkByteArray origData;
								if (MkZipCompressor::Uncompress(compData.GetPtr(), compData.GetSize(), origData) != fileInfo.origSize)
								{
									m_ErrorMsg = localFilePathForComp + L"\n압축 해제 후 크기가 다릅니다";
									break;
								}
								compData.Clear();

								// 파일로 기록
								MkInterfaceForFileWriting fwInterface;
								if (!fwInterface.SetUp(localFilePathForOrig, true, true))
								{
									m_ErrorMsg = localFilePathForOrig + L"\n파일 생성 실패.";
									break;
								}
								if (fwInterface.Write(origData, MkArraySection(0)) != fileInfo.origSize)
								{
									m_ErrorMsg = localFilePathForOrig + L"\n쓰기 오류.";
									break;
								}
								fwInterface.Clear();
								origData.Clear();

								// 압축 파일 삭제
								localFilePathForComp.DeleteCurrentFile();
							}
							else
							{
								// 크기만 검사
								if (localFilePathForOrig.GetFileSize() != fileInfo.origSize)
								{
									m_ErrorMsg = localFilePathForOrig + L"\n다운된 원본 파일 크기가 다릅니다. 맞는 크기 : " + MkStr(fileInfo.origSize);
									break;
								}
							}

							// 파일 수정시간 변경
							if (!localFilePathForOrig.SetWrittenTime(fileInfo.writtenTime))
							{
								m_ErrorMsg = localFilePathForOrig + L"\n파일 수정시간 변경 실패";
							}
						}
						while (false);
					}
				}

				if (m_ErrorMsg.Empty())
				{
					MK_DEV_PANEL.MsgToLog(L"  + " + fileInfo.filePath);
					++m_CurrentProgress;
				}
				else
				{
					m_MainState = eShowResult;
					m_MaxProgress = 0;
					m_CurrentProgress = 0;
				}
			}
		}
		break;

	case eUpdateFiles:
		{
			if (m_CurrentProgress == m_MaxProgress)
			{
				MkPathName localTempDir = MkPathName::GetRootDirectory() + TemporaryRepositoryDirName; // ex> D:\\Client\\__TempRep
				localTempDir.DeleteCurrentDirectory(true);

				MK_DEV_PANEL.MsgToLog(L"> 파일 패치가 완료되었습니다.");
				MK_DEV_PANEL.InsertEmptyLine();
				MK_DEV_PANEL.MsgToLog(L"> 파일 시스템 최적화를 실행합니다.");

				m_OptimizingTarget.Clear();
				MkFileManager::Instance().GetFileSystem().GetBlankChunks(40, m_OptimizingTarget);
				m_MaxProgress = m_OptimizingTarget.GetSize();
				m_CurrentProgress = 0;
				m_MainState = eOptimizeChunk;
			}
			else
			{
				_DownloadFileInfo& fileInfo = m_DownloadFileInfoList[m_CurrentProgress];

				MkPathName tempFilePath = m_TempDataPath + fileInfo.filePath; // ex> D:\\Client\\__TempRep\\data\\AAA\\BBB\\abc.mmd
				if (fileInfo.updateToRealFile)
				{
					MkPathName realFilePath;
					realFilePath.ConvertToRootBasisAbsolutePath(fileInfo.filePath); // ex> D:\\Client\\AAA\\BBB\\abc.mmd
					if (!tempFilePath.CopyCurrentFile(realFilePath, false)) // overwrite
					{
						m_ErrorMsg = fileInfo.filePath + L"\n복사 오류.";
					}
				}
				else
				{
					if (!MkFileManager::Instance().GetFileSystem().UpdateFromOriginalFile(m_TempDataPath, fileInfo.filePath))
					{
						m_ErrorMsg = fileInfo.filePath + L"\n갱신 오류.";
					}
				}

				if (m_ErrorMsg.Empty())
				{
					tempFilePath.DeleteCurrentFile();

					MK_DEV_PANEL.MsgToLog(MkStr((fileInfo.updateToRealFile) ? L"  R> " : L"  F> ") + fileInfo.filePath);
					++m_CurrentProgress;
				}
				else
				{
					m_MainState = eShowResult;
					m_MaxProgress = 0;
					m_CurrentProgress = 0;
				}
			}
		}
		break;

	case eOptimizeChunk:
		{
			if (m_CurrentProgress == m_MaxProgress)
			{
				MK_DEV_PANEL.MsgToLog(L"> 파일 시스템 최적화가 완료되었습니다.");
				MK_DEV_PANEL.InsertEmptyLine();

				m_MainState = eShowResult;
				m_MaxProgress = 0;
				m_CurrentProgress = 0;
			}
			else
			{
				unsigned int targetChunk = m_OptimizingTarget[m_CurrentProgress];
				if (MkFileManager::Instance().GetFileSystem().OptimizeChunk(targetChunk))
				{
					MK_DEV_PANEL.MsgToLog(MkStr(targetChunk) + L" 번 청크 최적화를 완료했습니다.");
					++m_CurrentProgress;
				}
				else
				{
					m_ErrorMsg = MkStr(targetChunk) + L" 번 청크 최적화를 실패했습니다.";

					m_MainState = eShowResult;
					m_MaxProgress = 0;
					m_CurrentProgress = 0;
				}
			}
		}
		break;

	case eShowResult:
		{
			if (!m_ErrorMsg.Empty())
			{
				MK_DEV_PANEL.MsgToLog(m_ErrorMsg);
				MK_DEV_PANEL.InsertEmptyLine();

				::MessageBox(NULL, m_ErrorMsg.GetPtr(), L"ERROR!!!", MB_OK);
				m_MainState = eReady;
			}
		}
		break;
	}
}

MkPatchFileDownloader::MkPatchFileDownloader()
{
	m_MainState = eReady;
	m_MaxProgress = 0;
	m_CurrentProgress = 0;
}

//------------------------------------------------------------------------------------------------//

void MkPatchFileDownloader::_FindFilesToDownload(const MkDataNode& node, const MkPathName& pathOffset, const MkPathName& moduleFileName)
{
	// 파일 검사
	MkArray<MkHashStr> subObjs;
	MkPathName::__GetSubFiles(node, subObjs);
	MK_INDEXING_LOOP(subObjs, i)
	{
		// module file의 경우는 이미 MkPatchStarter에서 패치되었을거라 간주하고 skip
		// 다시 패치받아도 보통은 문제 없지만 process에 올라간 파일이 바인드되어 있을 경우 error 발생 할 수 있으므로
		// (ex> 외장 메모리에서 실행될 경우 등) 깔끔하게 skip 하도록 함
		if (pathOffset.Empty())
		{
			MkPathName currFileName = subObjs[i];
			currFileName.ToLower();
			if (currFileName == moduleFileName)
				continue;
		}

		// patch file info
		unsigned int patchOrigSize = 0, patchCompSize = 0, patchWrittenTime = 0;
		const MkDataNode& fileNode = *node.GetChildNode(subObjs[i]);
		fileNode.GetData(MkPathName::KeyFileSize, patchOrigSize, 0);
		fileNode.GetData(MkPathName::KeyFileSize, patchCompSize, 1);
		fileNode.GetData(MkPathName::KeyWrittenTime, patchWrittenTime, 0);

		// 실제 파일이 존재하면 실제 파일과 다름 비교, 없으면 파일 시스템과 비교. 양쪽 다 없으면 다운 대상
		MkPathName filePath = pathOffset + subObjs[i];
		MkPathName realPath;
		realPath.ConvertToRootBasisAbsolutePath(filePath);

		bool realFileExist = realPath.CheckAvailable();
		bool downTheFile = (realFileExist) ?
			((realPath.GetFileSize() != patchOrigSize) || (realPath.GetWrittenTime() != patchWrittenTime)) :
			(MkFileManager::Instance().GetFileSystem().GetFileDifference(filePath, patchOrigSize, patchWrittenTime) != 0);

		// 다운 대상이면 이미 받아 놓은 임시 파일이 있는지 검사해 없거나 다르면 다운
		if (downTheFile)
		{
			_DownloadFileInfo& info = m_DownloadFileInfoList.PushBack();

			info.filePath = filePath;
			info.origSize = patchOrigSize;
			info.compSize = ((patchOrigSize > 0) && (patchCompSize > 0)) ? patchCompSize : 0;
			info.writtenTime = patchWrittenTime;

			MkPathName tmpFilePath = m_TempDataPath + filePath;
			info.alreadyDowned = (tmpFilePath.CheckAvailable() && (tmpFilePath.GetFileSize() == patchOrigSize) && (tmpFilePath.GetWrittenTime() == patchWrittenTime));

			// 파일 시스템이 없으면 실제 파일 대상
			const MkFileSystem& fs = MkFileManager::Instance().GetFileSystem();
			bool updateToRealFile = (fs.GetTotalChunkCount() == 0);
			if (!updateToRealFile)
			{
				// 실제 파일이 존재하면 대상
				updateToRealFile = realFileExist;

				// 파일 시스템 소속 여부 판단. 파일 시스템에도 소속되지 않는다면 실제 파일 대상
				if (!updateToRealFile)
				{
					updateToRealFile = (!(fs.CheckFileFilter(pathOffset) && fs.CheckFileFilter(filePath)));
				}
			}
			info.updateToRealFile = updateToRealFile;
		}
	}
	
	// 하위 디렉토리 검사
	subObjs.Clear();
	MkPathName::__GetSubDirectories(node, subObjs);
	MK_INDEXING_LOOP(subObjs, i)
	{
		MkPathName newOffset = pathOffset + subObjs[i];
		newOffset.CheckAndAddBackslash();
		_FindFilesToDownload(*node.GetChildNode(subObjs[i]), newOffset, moduleFileName); // 재귀
	}
}

unsigned int MkPatchFileDownloader::_CountTotalFiles(const MkDataNode& node)
{
	unsigned int files = 0;
	node.GetData(MkPathName::KeyFileCount, files, 0);

	MkArray<MkHashStr> subDirs;
	MkPathName::__GetSubDirectories(node, subDirs);
	MK_INDEXING_LOOP(subDirs, i)
	{
		files += _CountTotalFiles(*node.GetChildNode(subDirs[i]));
	}
	return files;
}

//------------------------------------------------------------------------------------------------//
